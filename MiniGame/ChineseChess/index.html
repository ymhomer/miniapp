<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>中國象棋</title>
    <style>
        /* CSS styles remain the same, no changes needed */
        :root {
            --chessScale: 1;
            --primary-color: #A0522D;
            --secondary-color: #D2B48C;
            --piece-red: #FF6347;
            --piece-black: #555;
            --text-color-dark: #333;
            --text-color-light: #fff;
            --highlight-color: #FFD700;
            --board-background: #f0e4d7;
            --control-background: #fff;
            --control-border: #ccc;
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        body {
            background: var(--board-background);
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text-color-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.6;
        }

        h1 {
            margin: 30px 0 20px;
            color: var(--primary-color);
            text-shadow: 1px 1px 2px var(--shadow-color);
        }

        #chessboardWrapper {
            width: 540px;
            height: 570px;
            margin: 20px auto;
            position: relative;
            box-shadow: 0 4px 12px var(--shadow-color);
            border-radius: 8px;
            overflow: hidden;
            padding-bottom: 30px;
        }

        #chessboard {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #boardSVG {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #boardSVG line {
            stroke: var(--primary-color);
            stroke-width: 1.5;
        }

        #boardSVG text {
            fill: var(--primary-color);
        }

        #piecesLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }

        .piece {
            position: absolute;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            text-align: center;
            line-height: 45px;
            font-size: 26px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 6px var(--shadow-color);
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }

        .piece:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .red {
            background: var(--piece-red);
            color: var(--text-color-light);
            border: 2px solid darken(var(--piece-red), 10%);
        }

        .black {
            background: var(--piece-black);
            color: var(--text-color-light);
            border: 2px solid lighten(var(--piece-black), 20%);
        }

        .selected {
            border: 3px solid var(--highlight-color);
            transform: scale(1.1) !important;
            box-shadow: 0 5px 10px var(--shadow-color);
        }

        .controls {
            width: 540px;
            max-width: 100%;
            margin: 30px auto;
            padding: 20px;
            background: var(--control-background);
            border: 1px solid var(--control-border);
            border-radius: 10px;
            box-shadow: 0 3px 9px var(--shadow-color);
        }

        .top-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .top-controls .left, .top-controls .right {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .top-controls input,
        .top-controls button {
            font-size: 16px;
            padding: 10px 16px;
            border: 1px solid var(--control-border);
            border-radius: 6px;
            outline: none;
            transition: all 0.3s;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .top-controls input:focus {
            border-color: var(--primary-color);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 5px rgba(var(--primary-color-rgb), 0.5);
        }

        .top-controls button {
            background: var(--primary-color);
            color: var(--text-color-light);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .top-controls button:hover {
            background: darken(var(--primary-color), 10%);
            box-shadow: 0 3px 6px var(--shadow-color);
        }

        .log-container {
            position: relative;
            margin-top: 15px;
        }

        #moveLog {
            font-size: 16px;
            max-height: 180px;
            overflow-y: auto;
            border: 1px solid var(--control-border);
            padding: 10px;
            background: #f9f9f9;
            border-radius: 6px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
            min-height: 60px;
        }

        #copyLogButton {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 14px;
            padding: 6px 10px;
            background: #6495ED;
            color: var(--text-color-light);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        #copyLogButton:hover {
            background: darken(#6495ED, 10%);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        @media (max-width: 600px) {
            :root {
                --chessScale: calc((100vw - 40px) / 540);
            }
            #chessboardWrapper {
                width: calc(540 * var(--chessScale));
                height: calc(570 * var(--chessScale));
                margin: 10px auto;
            }
            .controls {
                width: 95%;
                margin: 15px auto;
            }
            .top-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .top-controls .left, .top-controls .right {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
                margin-bottom: 10px;
            }
        }

        .valid-move {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 215, 0, 0.7);
            pointer-events: none;
            z-index: 1;
            box-shadow: 0 1px 3px var(--shadow-color);
        }

        .piece.cannon {
            border-width: 4px;
        }

        .piece.soldier {
            /* No changes needed here */
        }
    </style>
</head>
<body>
    <h1>中國象棋</h1>
    <div id="chessboardWrapper">
        <div id="chessboard">
            <svg id="boardSVG" width="540" height="570" viewBox="0 0 540 570"></svg>
            <div id="piecesLayer"></div>
        </div>
    </div>

    <div class="controls">
        <div class="top-controls">
            <div class="left">
                <input id="moveInput" type="text" placeholder="请输入棋谱（如兵3进1、马2进3、象3退1）" />
                <button id="moveSubmit">执行</button>
            </div>
            <div class="right">
                <button id="undoButton">悔棋</button>
            </div>
        </div>
        <div class="log-container">
            <div id="moveLog"></div>
            <button id="copyLogButton">复制日志</button>
        </div>
    </div>

    <script>
        const margin = 30,
            spacing = 60,
            boardCols = 9,
            boardRows = 10,
            pieceSize = 45;
        let currentPlayer = "red";
        let selectedPiece = null;
        let pieces = [];
        let moveHistory = [];
        let validMovesDisplay = [];

        /**
         * @function initPieces
         * @description Initializes the pieces array with the starting setup of Chinese Chess.
         */
        function initPieces() {
            pieces = [];
            const blackBack = ["車", "馬", "象", "士", "將", "士", "象", "馬", "車"];
            for (let x = 0; x < 9; x++) {
                pieces.push({ id: "b_back_" + x, type: blackBack[x], color: "black", x: x, y: 0 });
            }
            pieces.push({ id: "b_cannon_0", type: "炮", color: "black", x: 1, y: 2 });
            pieces.push({ id: "b_cannon_1", type: "炮", color: "black", x: 7, y: 2 });
            [0, 2, 4, 6, 8].forEach(x => {
                pieces.push({ id: "b_soldier_" + x, type: "卒", color: "black", x: x, y: 3 });
            });
            const redBack = ["車", "馬", "相", "仕", "帥", "仕", "相", "馬", "車"];
            for (let x = 0; x < 9; x++) {
                pieces.push({ id: "r_back_" + x, type: redBack[x], color: "red", x: x, y: 9 });
            }
            pieces.push({ id: "r_cannon_0", type: "炮", color: "red", x: 1, y: 7 });
            pieces.push({ id: "r_cannon_1", type: "炮", color: "red", x: 7, y: 7 });
            [0, 2, 4, 6, 8].forEach(x => {
                pieces.push({ id: "r_soldier_" + x, type: "兵", color: "red", x: x, y: 6 });
            });
        }

        /**
         * @function drawBoard
         * @description Draws the chessboard and markers on the SVG element.
         */
        function drawBoard() {
            const svg = document.getElementById("boardSVG");
            svg.innerHTML = "";
            for (let i = 0; i < boardRows; i++) {
                const y = margin + i * spacing;
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", margin);
                line.setAttribute("y1", y);
                line.setAttribute("x2", margin + (boardCols - 1) * spacing);
                line.setAttribute("y2", y);
                line.setAttribute("stroke", "black");
                svg.appendChild(line);
            }
            for (let j = 0; j < boardCols; j++) {
                const x = margin + j * spacing;
                if (j === 0 || j === boardCols - 1) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", x);
                    line.setAttribute("y1", margin);
                    line.setAttribute("x2", x);
                    line.setAttribute("y2", margin + (boardRows - 1) * spacing);
                    line.setAttribute("stroke", "black");
                    svg.appendChild(line);
                } else {
                    const line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line1.setAttribute("x1", x);
                    line1.setAttribute("y1", margin);
                    line1.setAttribute("x2", x);
                    line1.setAttribute("y2", margin + 4 * spacing);
                    line1.setAttribute("stroke", "black");
                    svg.appendChild(line1);
                    const line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line2.setAttribute("x1", x);
                    line2.setAttribute("y1", margin + 5 * spacing);
                    line2.setAttribute("x2", x);
                    line2.setAttribute("y2", margin + (boardRows - 1) * spacing);
                    line2.setAttribute("stroke", "black");
                    svg.appendChild(line2);
                }
            }
            let x1 = margin + 3 * spacing, y1 = margin,
                x2 = margin + 5 * spacing, y2 = margin + 2 * spacing;
            let diag1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            diag1.setAttribute("x1", x1);
            diag1.setAttribute("y1", y1);
            diag1.setAttribute("x2", x2);
            diag1.setAttribute("y2", y2);
            diag1.setAttribute("stroke", "black");
            svg.appendChild(diag1);
            let diag2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            diag2.setAttribute("x1", x2);
            diag2.setAttribute("y1", y1);
            diag2.setAttribute("x2", x1);
            diag2.setAttribute("y2", y2);
            diag2.setAttribute("stroke", "black");
            svg.appendChild(diag2);

            x1 = margin + 3 * spacing; y1 = margin + 7 * spacing;
            x2 = margin + 5 * spacing; y2 = margin + 9 * spacing;
            let diag3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            diag3.setAttribute("x1", x1);
            diag3.setAttribute("y1", y1);
            diag3.setAttribute("x2", x2);
            diag3.setAttribute("y2", y2);
            diag3.setAttribute("stroke", "black");
            svg.appendChild(diag3);
            let diag4 = document.createElementNS("http://www.w3.org/2000/svg", "line");
            diag4.setAttribute("x1", x2);
            diag4.setAttribute("y1", y1);
            diag4.setAttribute("x2", x1);
            diag4.setAttribute("y2", y2);
            diag4.setAttribute("stroke", "black");
            svg.appendChild(diag4);

            let text1 = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text1.setAttribute("x", margin + 2.5 * spacing);
            text1.setAttribute("y", margin + 4.6 * spacing);
            text1.setAttribute("font-size", "24");
            text1.setAttribute("text-anchor", "middle");
            text1.textContent = "楚河";
            svg.appendChild(text1);

            let text2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text2.setAttribute("x", margin + 5.5 * spacing);
            text2.setAttribute("y", margin + 4.6 * spacing);
            text2.setAttribute("font-size", "24");
            text2.setAttribute("text-anchor", "middle");
            text2.textContent = "漢界";
            svg.appendChild(text2);

            const markerPositions = [
                { x: 0, y: 3, side: "bottom" },
                { x: 2, y: 3, side: "bottom" },
                { x: 4, y: 3, side: "bottom" },
                { x: 6, y: 3, side: "bottom" },
                { x: 8, y: 3, side: "bottom" },
                { x: 1, y: 2, side: "bottom" },
                { x: 7, y: 2, side: "bottom" },
                { x: 0, y: 6, side: "top" },
                { x: 2, y: 6, side: "top" },
                { x: 4, y: 6, side: "top" },
                { x: 6, y: 6, side: "top" },
                { x: 8, y: 6, side: "top" },
                { x: 1, y: 7, side: "top" },
                { x: 7, y: 7, side: "top" }
            ];
            markerPositions.forEach(mp => {
                let cx = margin + mp.x * spacing,
                    cy = margin + mp.y * spacing;
                drawMarker(svg, cx, cy, mp.side);
            });
        }

        /**
         * @function drawMarker
         * @description Draws the 'L' shaped markers at specified positions on the board.
         * Modified to draw only inner 'L' shapes for outermost soldier positions.
         */
        function drawMarker(svg, cx, cy, side) {
            const markerGap = 4, markerLen = 10;
            if (side === "top" || side === "bottom") {
                // 判断是否是最外侧兵位 (x 坐标为 margin 或 margin + 8 * spacing)
                const isOuterSoldier = cx === margin || cx === margin + 8 * spacing;

                if (isOuterSoldier) {
                    if (cx === margin) { // 最左侧兵位，绘制右侧的 L (For the leftmost soldier, draw L markers on the right side)
                        // 右上角 L
                        let startX = cx + markerGap; let startY = cy - markerGap;
                        let line3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line3.setAttribute("x1", startX);
                        line3.setAttribute("y1", startY);
                        line3.setAttribute("x2", startX);
                        line3.setAttribute("y2", startY - markerLen);
                        line3.setAttribute("stroke", "black");
                        svg.appendChild(line3);
                        let line4 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line4.setAttribute("x1", startX);
                        line4.setAttribute("y1", startY);
                        line4.setAttribute("x2", startX + markerLen);
                        line4.setAttribute("y2", startY);
                        line4.setAttribute("stroke", "black");
                        svg.appendChild(line4);

                        // 右下角 L
                        startX = cx + markerGap; startY = cy + markerGap;
                        let line7 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line7.setAttribute("x1", startX);
                        line7.setAttribute("y1", startY);
                        line7.setAttribute("x2", startX);
                        line7.setAttribute("y2", startY + markerLen);
                        line7.setAttribute("stroke", "black");
                        svg.appendChild(line7);
                        let line8 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line8.setAttribute("x1", startX);
                        line8.setAttribute("y1", startY);
                        line8.setAttribute("x2", startX + markerLen);
                        line8.setAttribute("y2", startY);
                        line8.setAttribute("stroke", "black");
                        svg.appendChild(line8);


                    } else if (cx === margin + 8 * spacing) { // 最右侧兵位，绘制左侧的 L (For the rightmost soldier, draw L markers on the left side)
                        // 左上角 L
                        let startX = cx - markerGap; let startY = cy - markerGap;
                        let line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line1.setAttribute("x1", startX);
                        line1.setAttribute("y1", startY);
                        line1.setAttribute("x2", startX);
                        line1.setAttribute("y2", startY - markerLen);
                        line1.setAttribute("stroke", "black");
                        svg.appendChild(line1);
                        let line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line2.setAttribute("x1", startX);
                        line2.setAttribute("y1", startY);
                        line2.setAttribute("x2", startX - markerLen);
                        line2.setAttribute("y2", startY);
                        line2.setAttribute("stroke", "black");
                        svg.appendChild(line2);

                        // 左下角 L
                        startX = cx - markerGap; startY = cy + markerGap;
                        let line5 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line5.setAttribute("x1", startX);
                        line5.setAttribute("y1", startY);
                        line5.setAttribute("x2", startX);
                        line5.setAttribute("y2", startY + markerLen);
                        line5.setAttribute("stroke", "black");
                        svg.appendChild(line5);
                        let line6 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line6.setAttribute("x1", startX);
                        line6.setAttribute("y1", startY);
                        line6.setAttribute("x2", startX - markerLen);
                        line6.setAttribute("y2", startY);
                        line6.setAttribute("stroke", "black");
                        svg.appendChild(line6);
                    }


                } else { //  中间兵位和炮位，绘制完整的四个L (For center soldiers and cannons, draw full four L markers)
                    // 左上角 L
                    let startX = cx - markerGap, startY = cy - markerGap;
                    let line1 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line1.setAttribute("x1", startX);
                    line1.setAttribute("y1", startY);
                    line1.setAttribute("x2", startX);
                    line1.setAttribute("y2", startY - markerLen);
                    line1.setAttribute("stroke", "black");
                    svg.appendChild(line1);
                    let line2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line2.setAttribute("x1", startX);
                    line2.setAttribute("y1", startY);
                    line2.setAttribute("x2", startX - markerLen);
                    line2.setAttribute("y2", startY);
                    line2.setAttribute("stroke", "black");
                    svg.appendChild(line2);

                    // 右上角 L
                    startX = cx + markerGap; startY = cy - markerGap;
                    let line3 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line3.setAttribute("x1", startX);
                    line3.setAttribute("y1", startY);
                    line3.setAttribute("x2", startX);
                    line3.setAttribute("y2", startY - markerLen);
                    line3.setAttribute("stroke", "black");
                    svg.appendChild(line3);
                    let line4 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line4.setAttribute("x1", startX);
                    line4.setAttribute("y1", startY);
                    line4.setAttribute("x2", startX + markerLen);
                    line4.setAttribute("y2", startY);
                    line4.setAttribute("stroke", "black");
                    svg.appendChild(line4);

                    // 左下角 L
                    startX = cx - markerGap; startY = cy + markerGap;
                    let line5 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line5.setAttribute("x1", startX);
                    line5.setAttribute("y1", startY);
                    line5.setAttribute("x2", startX);
                    line5.setAttribute("y2", startY + markerLen);
                    line5.setAttribute("stroke", "black");
                    svg.appendChild(line5);
                    let line6 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line6.setAttribute("x1", startX);
                    line6.setAttribute("y1", startY);
                    line6.setAttribute("x2", startX - markerLen);
                    line6.setAttribute("y2", startY);
                    line6.setAttribute("stroke", "black");
                    svg.appendChild(line6);

                    // 右下角 L
                    startX = cx + markerGap; startY = cy + markerGap;
                    let line7 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line7.setAttribute("x1", startX);
                    line7.setAttribute("y1", startY);
                    line7.setAttribute("x2", startX);
                    line7.setAttribute("y2", startY + markerLen);
                    line7.setAttribute("stroke", "black");
                    svg.appendChild(line7);
                    let line8 = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line8.setAttribute("x1", startX);
                    line8.setAttribute("y1", startY);
                    line8.setAttribute("x2", startX + markerLen);
                    line8.setAttribute("y2", startY);
                    line8.setAttribute("stroke", "black");
                    svg.appendChild(line8);
                }
            }
        }

        /**
         * @function renderPieces
         * @description Renders the chess pieces on the board based on the 'pieces' array.
         */
        function renderPieces() {
            const layer = document.getElementById("piecesLayer");
            layer.innerHTML = '';
            pieces.forEach(piece => {
                const div = document.createElement("div");
                let pieceClassName = "piece " + piece.color + (selectedPiece && selectedPiece.id === piece.id ? " selected" : "");
                if (piece.type === "炮") {
                    pieceClassName += " cannon";
                } else if (piece.type === "兵" || piece.type === "卒") {
                    pieceClassName += " soldier";
                }
                div.className = pieceClassName;
                div.textContent = piece.type;
                div.style.left = (margin * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--chessScale')) + piece.x * spacing * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--chessScale')) - pieceSize / 2) + "px";
                div.style.top = (margin * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--chessScale')) + piece.y * spacing * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--chessScale')) - pieceSize / 2) + "px";
                div.dataset.id = piece.id;
                div.addEventListener("click", function(e) {
                    e.stopPropagation();
                    handlePieceClick(piece);
                });
                layer.appendChild(div);
            });
            renderValidMoves();
        }

        /**
         * @function handlePieceClick
         * @description Handles the click event on a chess piece.
         * Selects the piece if it belongs to the current player, otherwise attempts to move the selected piece.
         * @param {object} piece - The piece object that was clicked.
         */
        function handlePieceClick(piece) {
            if (piece.color === currentPlayer) {
                selectPiece(piece);
            } else {
                if (selectedPiece && isValidMove(selectedPiece, piece.x, piece.y)) {
                    attemptMove(selectedPiece, piece.x, piece.y);
                }
            }
        }

        /**
         * @function selectPiece
         * @description Selects a chess piece, updates UI to show selection and valid moves.
         * @param {object} piece - The piece object to be selected.
         */
        function selectPiece(piece) {
            if (selectedPiece) {
                if (selectedPiece.id === piece.id) {
                    deselectPiece();
                } else {
                    selectedPiece = piece;
                }
            } else {
                selectedPiece = piece;
            }
            renderPieces();
            if (selectedPiece) {
                showValidMoves(selectedPiece);
            }
        }

        /**
         * @function deselectPiece
         * @description Deselects the currently selected piece and clears valid move indicators.
         */
        function deselectPiece() {
            selectedPiece = null;
            clearValidMovesDisplay();
            renderPieces();
        }

        /**
         * @function showValidMoves
         * @description Displays valid move indicators on the board for the selected piece.
         * @param {object} piece - The selected piece object.
         */
        function showValidMoves(piece) {
            clearValidMovesDisplay();
            const validMoves = getValidMoves(piece);
            validMoves.forEach(move => {
                const indicator = document.createElement('div');
                indicator.className = 'valid-move';
                indicator.style.left = (margin + move.x * spacing - 10) + 'px';
                indicator.style.top = (margin + move.y * spacing - 10) + 'px';
                indicator.addEventListener('click', function(e) {
                    e.stopPropagation();
                    attemptMove(piece, move.x, move.y);
                });
                document.getElementById('piecesLayer').appendChild(indicator);
                validMovesDisplay.push(indicator);
            });
        }

        /**
         * @function clearValidMovesDisplay
         * @description Clears all valid move indicators from the board.
         */
        function clearValidMovesDisplay() {
            validMovesDisplay.forEach(indicator => indicator.remove());
            validMovesDisplay = [];
        }

        /**
         * @function renderValidMoves
         * @description Renders valid move indicators - currently calls showValidMoves if a piece is selected.
         */
        function renderValidMoves() {
            if (selectedPiece) {
                showValidMoves(selectedPiece);
            }
        }

        /**
         * @function getPieceAt
         * @description Retrieves the piece object at a given board position (x, y).
         * @param {number} x - The x-coordinate on the board.
         * @param {number} y - The y-coordinate on the board.
         * @returns {object|undefined} The piece object at (x, y) or undefined if no piece exists.
         */
        function getPieceAt(x, y) {
            return pieces.find(p => p.x === x && p.y === y);
        }

        /**
         * @function isPathClear
         * @description Checks if the path between two points on the board is clear of pieces.
         * Used for pieces like 車 (Chariot) and 炮 (Cannon) that move along straight lines.
         * @param {number} x1 - Start x-coordinate.
         * @param {number} y1 - Start y-coordinate.
         * @param {number} x2 - End x-coordinate.
         * @param {number} y2 - End y-coordinate.
         * @returns {boolean} True if the path is clear, false otherwise.
         */
        function isPathClear(x1, y1, x2, y2) {
            if (x1 === x2) {
                let minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                for (let y = minY + 1; y < maxY; y++) {
                    if (getPieceAt(x1, y)) return false;
                }
            } else if (y1 === y2) {
                let minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                for (let x = minX + 1; x < maxX; x++) {
                    if (getPieceAt(x, y1)) return false;
                }
            }
            return true;
        }

        /**
         * @function countPiecesBetween
         * @description Counts the number of pieces between two points on the board, exclusive of the start and end points.
         * Used specifically for 炮 (Cannon) movement to check for jumping over pieces.
         * @param {number} x1 - Start x-coordinate.
         * @param {number} y1 - Start y-coordinate.
         * @param {number} x2 - End x-coordinate.
         * @param {number} y2 - End y-coordinate.
         * @returns {number} The number of pieces between the start and end points.
         */
        function countPiecesBetween(x1, y1, x2, y2) {
            let count = 0;
            if (x1 === x2) {
                let minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                for (let y = minY + 1; y < maxY; y++) {
                    if (getPieceAt(x1, y)) count++;
                }
            } else if (y1 === y2) {
                let minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                for (let x = minX + 1; x < maxX; x++) {
                    if (getPieceAt(x, y1)) count++;
                }
            }
            return count;
        }

        /**
         * @function getValidMoves
         * @description Gets all valid moves for a given piece.
         * Iterates through all board positions and checks if the move to each position is valid.
         * @param {object} piece - The piece object to get valid moves for.
         * @returns {Array<object>} An array of valid move objects, each containing x and y coordinates.
         */
        function getValidMoves(piece) {
            const validMoves = [];
            for (let y = 0; y < boardRows; y++) {
                for (let x = 0; x < boardCols; x++) {
                    if (isValidMove(piece, x, y)) {
                        validMoves.push({x: x, y: y});
                    }
                }
            }
            return validMoves;
        }

        /**
         * @function isValidMove
         * @description Checks if a move is valid for a given piece to a target position (newX, newY).
         * Implements the movement rules for each type of Chinese Chess piece.
         * @param {object} piece - The piece object attempting to move.
         * @param {number} newX - The target x-coordinate.
         * @param {number} newY - The target y-coordinate.
         * @returns {boolean} True if the move is valid, false otherwise.
         */
        function isValidMove(piece, newX, newY) {
            if (newX < 0 || newX > boardCols - 1 || newY < 0 || newY > boardRows - 1) return false;
            const targetPiece = getPieceAt(newX, newY);
            if (targetPiece && targetPiece.color === piece.color) return false;
            const dx = newX - piece.x, dy = newY - piece.y,
                adx = Math.abs(dx), ady = Math.abs(dy);
            switch (piece.type) {
                case "車":
                    if (dx !== 0 && dy !== 0) return false;
                    return isPathClear(piece.x, piece.y, newX, newY);
                case "馬":
                    if ((adx === 2 && ady === 1) || (adx === 1 && ady === 2)) {
                        if (adx === 2 && ady === 1) {
                            let blockX = piece.x + dx / 2;
                            if (getPieceAt(blockX, piece.y)) return false;
                        } else if (adx === 1 && ady === 2) {
                            let blockY = piece.y + dy / 2;
                            if (getPieceAt(piece.x, blockY)) return false;
                        }
                        return true;
                    }
                    return false;
                case "炮":
                    if (dx !== 0 && dy !== 0) return false;
                    const between = countPiecesBetween(piece.x, piece.y, newX, newY);
                    if (targetPiece) {
                        return between === 1;
                    } else {
                        return between === 0;
                    }
                case "兵":
                case "卒":
                    if (ady === 1 && dx === 0) {
                        if (piece.color === "red") {
                            return newY < piece.y;
                        } else {
                            return newY > piece.y;
                        }
                    }
                    if (piece.color === "red" && newY === piece.y && dx === 1 && newY < 5) return true;
                    if (piece.color === "red" && newY === piece.y && dx === -1 && newY < 5) return true;
                    if (piece.color === "black" && newY === piece.y && dx === 1 && newY > 4) return true;
                    if (piece.color === "black" && newY === piece.y && dx === -1 && newY > 4) return true;

                    return false;
                case "士":
                case "仕":
                    if (adx !== 1 || ady !== 1) return false;
                    if (piece.color === "red") {
                        if (newX < 3 || newX > 5 || newY < 7 || newY > 9) return false;
                    } else {
                        if (newX < 3 || newX > 5 || newY < 0 || newY > 2) return false;
                    }
                    return true;
                case "象":
                case "相":
                    if (adx !== 2 || ady !== 2) return false;
                    let eyeX = piece.x + dx / 2, eyeY = piece.y + dy / 2;
                    if (getPieceAt(eyeX, eyeY)) return false;
                    if (piece.color === "red") {
                        if (newY < 5) return false;
                    } else {
                        if (newY > 4) return false;
                    }
                    return true;
                case "將":
                case "帥":
                    if (adx + ady !== 1) return false;
                    if (piece.color === "red") {
                        if (newX < 3 || newX > 5 || newY < 7 || newY > 9) return false;
                    } else {
                        if (newX < 3 || newX > 5 || newY < 0 || newY > 2) return false;
                    }
                    let enemyGeneral = pieces.find(p => (p.type === "將" || p.type === "帥") && p.color !== piece.color);
                    if (enemyGeneral && newX === enemyGeneral.x) {
                        if (isPathClear(newX, newY, enemyGeneral.x, enemyGeneral.y)) return false;
                    }
                    return true;
                default:
                    return false;
            }
        }

        /**
         * @function attemptMove
         * @description Attempts to move a piece to a new position.
         * If the move is valid, updates piece position, captures target if any, and switches player turn.
         * @param {object} piece - The piece object to move.
         * @param {number} newX - The target x-coordinate.
         * @param {number} newY - The target y-coordinate.
         */
        function attemptMove(piece, newX, newY) {
            if (isValidMove(piece, newX, newY)) {
                const target = getPieceAt(newX, newY);
                const move = {
                    pieceId: piece.id,
                    pieceType: piece.type,
                    pieceColor: piece.color,
                    oldX: piece.x,
                    oldY: piece.y,
                    newX: newX,
                    newY: newY,
                    captured: target ? { id: target.id, type: target.type, color: target.color, x: target.x, y: target.y } : null,
                    currentPlayerBefore: currentPlayer
                };
                moveHistory.push(move);
                if (target) {
                    pieces = pieces.filter(p => p.id !== target.id);
                }
                piece.x = newX;
                piece.y = newY;
                currentPlayer = currentPlayer === "red" ? "black" : "red";
                deselectPiece();
                renderPieces();
                updateMoveLog();
            }
        }

        /**
         * @function undoMove
         * @description Undoes the last move by reverting piece positions and game state.
         */
        function undoMove() {
            if (moveHistory.length === 0) return;
            const lastMove = moveHistory.pop();
            let movedPiece = pieces.find(p => p.id === lastMove.pieceId);
            if (movedPiece) {
                movedPiece.x = lastMove.oldX;
                movedPiece.y = lastMove.oldY;
            }
            if (lastMove.captured) {
                pieces.push(lastMove.captured);
            }
            currentPlayer = lastMove.currentPlayerBefore;
            deselectPiece();
            renderPieces();
            updateMoveLog();
        }
        document.getElementById("undoButton").addEventListener("click", undoMove);

        /**
         * @function getFileNumber
         * @description Gets the file number for notation based on color and x-coordinate.
         * @param {string} color - The color of the player ("red" or "black").
         * @param {number} x - The x-coordinate.
         * @returns {number} The file number for notation.
         */
        function getFileNumber(color, x) {
            return color === "red" ? (9 - x) : (x + 1);
        }

        /**
         * @function getRankNumber
         * @description Gets the rank number for notation based on color and y-coordinate.
         * @param {string} color - The color of the player ("red" or "black").
         * @param {number} y - The y-coordinate.
         * @returns {number} The rank number for notation.
         */
        function getRankNumber(color, y) {
            return color === "red" ? (boardRows - y) : (y + 1);
        }

        /**
         * @function getMoveNotation
         * @description Generates Chinese Chess notation for a move object.
         * @param {object} move - The move object.
         * @returns {string} Chinese Chess notation string.
         */
        function getMoveNotation(move) {
            let notation = "";
            if (move.pieceType === "象" || move.pieceType === "相") {
                const label = currentPlayer === "red" ? "相" : "象";
                let startFile = getFileNumber(move.pieceColor, move.oldX);
                let destFile = getFileNumber(move.pieceColor, move.newX);
                let direction = (move.pieceColor === "red")
                    ? (move.newY < move.oldY ? "进" : "退")
                    : (move.newY > move.oldY ? "进" : "退");
                notation = label + startFile + direction + destFile;
            }
            else if (move.pieceType === "馬") {
                let startFile = getFileNumber(move.pieceColor, move.oldX);
                let destFile = getFileNumber(move.pieceColor, move.newX);
                let direction = (move.pieceColor === "red")
                    ? (move.newY < move.oldY ? "进" : "退")
                    : (move.newY > move.oldY ? "进" : "退");
                notation = "馬" + startFile + direction + destFile;
            }
            else if (move.oldY === move.newY) {
                let originFile = getFileNumber(move.pieceColor, move.oldX);
                let destFile = getFileNumber(move.pieceColor, move.newX);
                notation = move.pieceType + originFile + "平" + destFile;
            }
            else {
                let originRank = getRankNumber(move.pieceColor, move.oldY);
                let destRank = getRankNumber(move.pieceColor, move.newY);
                let step = Math.abs(destRank - originRank);
                let direction = (move.pieceColor === "red")
                    ? (move.newY < move.oldY ? "进" : "退")
                    : (move.newY > move.oldY ? "进" : "退");
                notation = move.pieceType + getFileNumber(move.pieceColor, move.oldX) + direction + step;
            }
            if (move.captured) {
                notation += "（吃" + move.captured.type + "）";
            }
            return notation;
        }

        /**
         * @function updateMoveLog
         * @description Updates the move log display with the move history.
         */
        function updateMoveLog() {
            const logDiv = document.getElementById("moveLog");
            logDiv.innerHTML = "";
            moveHistory.forEach(move => {
                const notation = getMoveNotation(move);
                const prefix = move.pieceColor === "red" ? "【红棋】" : "【黑棋】";
                const p = document.createElement("div");
                p.textContent = prefix + notation;
                logDiv.appendChild(p);
            });
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        /**
         * @function parseMoveText
         * @description Parses the input move text and attempts to execute the move.
         * Supports simplified and traditional Chinese characters for piece types.
         * @param {string} moveText - The Chinese Chess notation text to parse.
         */
        function parseMoveText(moveText) {
            if (moveText.length < 4) {
                alert("棋谱格式不正确");
                return;
            }
            let pieceType = moveText.charAt(0);
            if (pieceType === "马") pieceType = "馬";
            if (pieceType === "象" || pieceType === "相") {
                pieceType = currentPlayer === "red" ? "相" : "象";
            }
            const initFile = parseInt(moveText.charAt(1), 10);
            const moveChar = moveText.charAt(2);
            const destNum = parseInt(moveText.charAt(3), 10);
            const candidate = pieces.find(p => p.color === currentPlayer && p.type === pieceType && getFileNumber(currentPlayer, p.x) === initFile);
            if (!candidate) {
                alert("未找到符合条件的棋子");
                return;
            }
            let newX = candidate.x, newY = candidate.y;
            if (pieceType === "相" || pieceType === "象") {
                newX = currentPlayer === "red" ? (9 - destNum) : (destNum - 1);
                if (moveChar === "进") {
                    newY = candidate.y - 2;
                } else if (moveChar === "退") {
                    newY = candidate.y + 2;
                } else {
                    alert("象/相只支持“进”或“退”");
                    return;
                }
            }
            else if (pieceType === "馬") {
                newX = currentPlayer === "red" ? (9 - destNum) : (destNum - 1);
                if (moveChar === "进") {
                    newY = candidate.y - 2;
                } else if (moveChar === "退") {
                    newY = candidate.y + 2;
                } else {
                    alert("马只支持“进”或“退”");
                    return;
                }
            }
            else {
                if (moveChar === "平") {
                    newX = currentPlayer === "red" ? (9 - destNum) : (destNum - 1);
                    newY = candidate.y;
                } else if (moveChar === "进") {
                    newY = currentPlayer === "red" ? candidate.y - destNum : candidate.y + destNum;
                } else if (moveChar === "退") {
                    newY = currentPlayer === "red" ? candidate.y + destNum : candidate.y - destNum;
                } else {
                    alert("未知的移动标记：" + moveChar);
                    return;
                }
            }
            attemptMove(candidate, newX, newY);
        }

        /**
         * @function initGame
         * @description Initializes the game by setting up pieces and drawing the board.
         */
        function initGame() {
            initPieces();
            drawBoard();
            renderPieces();
        }

        /**
         * Event listener for Undo Button.
         * Calls undoMove function on click.
         */
        document.getElementById("undoButton").addEventListener("click", undoMove);

        /**
         * Event listener for Move Submit Button.
         * Parses and executes move from input text field on click.
         */
        document.getElementById("moveSubmit").addEventListener("click", function() {
            const moveText = document.getElementById("moveInput").value.trim();
            if (moveText) {
                parseMoveText(moveText);
                document.getElementById("moveInput").value = "";
            }
        });

        /**
         * Event listener for Move Input field (keydown event).
         * Triggers Move Submit button click if Enter key is pressed.
         */
        document.getElementById("moveInput").addEventListener("keydown", function(e) {
            if (e.key === "Enter") {
                document.getElementById("moveSubmit").click();
            }
        });

        /**
         * Event listener for Copy Log Button.
         * Copies the move log text to clipboard on click.
         */
        document.getElementById("copyLogButton").addEventListener("click", function() {
            const logText = document.getElementById("moveLog").innerText;
            navigator.clipboard.writeText(logText).then(() => {
                alert("日志已复制到剪贴板！");
            }).catch(err => {
                alert("复制失败：" + err);
            });
        });

        /**
         * Event listener for Chessboard Wrapper (click event).
         * Handles clicks on the chessboard to attempt moves if a piece is selected.
         */
        document.getElementById("chessboardWrapper").addEventListener("click", function(e) {
            if (!selectedPiece) return;
            const rect = this.getBoundingClientRect();
            const scale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--chessScale'));
            const x = (e.clientX - rect.left) / scale,
                y = (e.clientY - rect.top) / scale;
            let col = Math.round((x - margin) / spacing),
                row = Math.round((y - margin) / spacing);
            attemptMove(selectedPiece, col, row);
        });


        initGame(); // Initialize the game when script loads.
    </script>
</body>
</html>