<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw A Circle</title>
    <style>
        :root {
            --bg-color: #f0f0f0;
            --container-bg-color: #ffffff;
            --border-color: #cccccc;
            --primary-color: #3498db;
            --text-color: #333333;
            --score-bg-good: #2ecc71;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --button-primary: #2980b9;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-color);
            line-height: 1.6;
            padding: 10px;
            overflow-y: auto; /* Allow scrolling on small screens */
        }

        .game-container {
            width: 100%;
            max-width: 600px;
            background-color: var(--container-bg-color);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .control-panel {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #navigationButton {
            padding: 12px 25px;
            font-size: 1rem;
            font-weight: bold;
            color: #ffffff;
            background-color: var(--primary-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        
        #navigationButton:hover {
            background-color: var(--button-primary);
            transform: translateY(-2px);
        }
        
        #navigationButton:active {
            transform: translateY(0);
        }

        .content-view {
            display: none;
            flex-direction: column;
            gap: 20px;
        }

        .content-view.active {
            display: flex;
        }
        
        .main-game-layout {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 100%;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            touch-action: none;
            z-index: 2;
        }
        
        #highScoreCanvas, #idealCircleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        #highScoreCanvas {
            z-index: 3; /* Ensure high score circle is on top */
        }
        
        p.instructions {
            text-align: center;
            font-size: 0.9rem;
            color: #666;
            margin-top: -5px;
        }

        .score-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            text-align: center;
        }

        .score-card {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #eee;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .score-card.overall-score-card {
            grid-column: 1 / -1; /* Span across both columns */
        }

        .score-card h3 {
            font-size: 0.9rem;
            margin-bottom: 2px;
            color: #555;
        }
        
        .score-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        .score-card.overall-score-card .score-value {
            font-size: 2.5rem;
            color: var(--score-bg-good);
        }

        #historyView ul {
            list-style: none;
            padding: 0;
        }

        #historyView li {
            padding: 12px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #historyView li:last-child {
            border-bottom: none;
        }

        .history-item-scores {
            flex-grow: 1;
            text-align: left;
            font-size: 0.9rem;
        }

        .history-item-date {
            font-size: 0.75rem;
            color: #999;
            text-align: right;
            white-space: nowrap;
        }

        #highScoreView {
            text-align: center;
        }

        #highScoreView h2 {
            font-size: 1.5rem;
            color: var(--score-bg-good);
            margin-bottom: 10px;
        }
        
        #highScoreView .score-details {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

    </style>
</head>
<body>

    <div class="game-container">
        <h1>Draw A Circle</h1>
        
        <button id="navigationButton">Go to History</button>

        <div id="gameView" class="content-view active">
            <div class="main-game-layout">
                <div class="canvas-container">
                    <canvas id="drawingCanvas"></canvas>
                    <canvas id="idealCircleCanvas"></canvas>
                </div>
                <p class="instructions">Draw a perfect circle with a single stroke. Your score will be calculated when you release the mouse or lift your finger.</p>
            </div>
            
            <div class="score-container">
                <div class="score-card">
                    <h3>Roundness</h3>
                    <div class="score-value" id="roundnessScore">0</div>
                </div>
                <div class="score-card">
                    <h3>Perimeter</h3>
                    <div class="score-value" id="perimeterScore">0</div>
                </div>
                <div class="score-card">
                    <h3>Closure</h3>
                    <div class="score-value" id="closureScore">0</div>
                </div>
                <div class="score-card overall-score-card">
                    <h3>Overall Score</h3>
                    <div class="score-value" id="overallScore">0</div>
                </div>
            </div>
        </div>

        <div id="historyView" class="content-view">
            <h2>Game History</h2>
            <ul id="historyList"></ul>
        </div>

        <div id="highScoreView" class="content-view">
            <h2>Highest Score</h2>
            <div id="highScoreDisplay"></div>
            <div class="main-game-layout" style="margin-top: 20px;">
                <div class="canvas-container">
                    <canvas id="highScoreCanvas"></canvas>
                </div>
                <p class="instructions">This is your best circle so far!</p>
            </div>
        </div>
    </div>

    <script>
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const idealCircleCanvas = document.getElementById('idealCircleCanvas');
        const idealCircleCtx = idealCircleCanvas.getContext('2d');
        const highScoreCanvas = document.getElementById('highScoreCanvas');
        const highScoreCtx = highScoreCanvas.getContext('2d');
        const navigationButton = document.getElementById('navigationButton');
        
        const gameView = document.getElementById('gameView');
        const historyView = document.getElementById('historyView');
        const highScoreView = document.getElementById('highScoreView');

        let isDrawing = false;
        let points = [];
        let drawingRadius = 0;
        let drawingCenter = { x: 0, y: 0 };
        let activeViewIndex = 0;
        const views = [gameView, historyView, highScoreView];
        const buttonTexts = ['Go to History', 'Go to High Score', 'Go to Game'];
        
        const historyKey = 'circleGameHistory';
        const highScoreKey = 'circleGameHighScore';

        const scaleCanvas = () => {
            const rect = drawingCanvas.getBoundingClientRect();
            [drawingCanvas, idealCircleCanvas, highScoreCanvas].forEach(canvas => {
                canvas.width = rect.width * devicePixelRatio;
                canvas.height = rect.height * devicePixelRatio;
                canvas.getContext('2d').scale(devicePixelRatio, devicePixelRatio);
            });
        };

        window.addEventListener('resize', scaleCanvas);
        scaleCanvas();

        const getPos = (event) => {
            const rect = drawingCanvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : null);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : null);
            
            if (clientX === null || clientY === null) return null;
            
            return {
                x: (clientX - rect.left),
                y: (clientY - rect.top)
            };
        };

        const startDrawing = (event) => {
            const pos = getPos(event);
            if (!pos) return;
            isDrawing = true;
            points = [];
            
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            idealCircleCtx.clearRect(0, 0, idealCircleCanvas.width, idealCircleCanvas.height);
            updateScores(0, 0, 0, 0);
            
            drawingCtx.beginPath();
            points.push(pos);
            drawingCtx.moveTo(pos.x, pos.y);
            drawingCtx.strokeStyle = '#3498db';
            drawingCtx.lineWidth = 4;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
        };

        const draw = (event) => {
            if (!isDrawing) return;
            const pos = getPos(event);
            if (!pos) return;
            points.push(pos);
            drawingCtx.lineTo(pos.x, pos.y);
            drawingCtx.stroke();
        };

        const stopDrawing = (event) => {
            if (!isDrawing) return;
            isDrawing = false;
            if (points.length > 10) {
                calculateAndSaveScore();
            } else {
                updateScores(0, 0, 0, 0);
            }
        };

        const calculateAndSaveScore = () => {
            if (points.length < 2) return;

            const { center, radius } = fitCircle(points);
            drawingCenter = center;
            drawingRadius = radius;

            if (drawingCenter.x && drawingCenter.y && drawingRadius) {
                drawIdealCircle(drawingCenter, drawingRadius, idealCircleCtx);
            }

            const roundnessScore = calculateRoundnessScore();
            const perimeterScore = calculatePerimeterScore();
            const closureScore = calculateClosureScore();
            const overallScore = (roundnessScore * 0.8) + (perimeterScore * 0.1) + (closureScore * 0.1);

            updateScores(roundnessScore, perimeterScore, closureScore, overallScore);
            
            saveScoreToHistory({
                roundness: Math.round(roundnessScore),
                perimeter: Math.round(perimeterScore),
                closure: Math.round(closureScore),
                overall: Math.round(overallScore),
                date: new Date().toLocaleString(),
                points: points
            });
        };

        const drawIdealCircle = (center, radius, ctx) => {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
        };
        
        const drawPath = (pointsToDraw, ctx, strokeStyle) => {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            if (pointsToDraw.length < 2) return;
            
            ctx.beginPath();
            ctx.moveTo(pointsToDraw[0].x, pointsToDraw[0].y);
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            pointsToDraw.forEach(p => {
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
            });
        };

        const saveScoreToHistory = (scoreData) => {
            const history = JSON.parse(localStorage.getItem(historyKey) || '[]');
            history.unshift(scoreData);
            localStorage.setItem(historyKey, JSON.stringify(history));
            
            const currentHighScore = JSON.parse(localStorage.getItem(highScoreKey) || '{"overall": 0}');
            if (scoreData.overall > currentHighScore.overall) {
                localStorage.setItem(highScoreKey, JSON.stringify(scoreData));
            }
        };

        const fitCircle = (pts) => {
            if (pts.length < 3) return { center: {x: 0, y: 0}, radius: 0 };
            
            let sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0, sumX3 = 0, sumY3 = 0, sumXY = 0, sumX1Y2 = 0, sumX2Y1 = 0;
            const n = pts.length;
            
            pts.forEach(p => {
                const x = p.x;
                const y = p.y;
                sumX += x;
                sumY += y;
                sumX2 += x * x;
                sumY2 += y * y;
                sumX3 += x * x * x;
                sumY3 += y * y * y;
                sumXY += x * y;
                sumX1Y2 += x * y * y;
                sumX2Y1 += x * x * y;
            });
            
            const C = n * sumX2 - sumX * sumX;
            const D = n * sumXY - sumX * sumY;
            const E = n * sumX3 + n * sumX1Y2 - (sumX2 + sumY2) * sumX;
            const G = n * sumY2 - sumY * sumY;
            const H = n * sumX2Y1 + n * sumY3 - (sumX2 + sumY2) * sumY;
            
            const a = (E * G - D * H) / (C * G - D * D);
            const b = (C * H - D * E) / (C * G - D * D);
            
            const centerX = a / 2;
            const centerY = b / 2;
            
            const radius = Math.sqrt(sumX2 / n + sumY2 / n - a * sumX / n - b * sumY / n + (a * a + b * b) / 4);

            return { center: { x: centerX, y: centerY }, radius: radius };
        };

        const calculateRoundnessScore = () => {
            if (drawingRadius === 0) return 0;
            let errorSum = 0;
            points.forEach(p => {
                const distance = Math.sqrt(Math.pow(p.x - drawingCenter.x, 2) + Math.pow(p.y - drawingCenter.y, 2));
                errorSum += Math.pow(distance - drawingRadius, 2);
            });
            const meanSquaredError = errorSum / points.length;
            const normalizedError = Math.sqrt(meanSquaredError) / drawingRadius;
            return Math.max(0, 100 - (normalizedError * 200));
        };

        const calculatePerimeterScore = () => {
            const idealRadius = Math.min(drawingCanvas.width, drawingCanvas.height) * 0.4;
            const idealPerimeter = 2 * Math.PI * idealRadius;
            
            let pathLength = 0;
            for (let i = 1; i < points.length; i++) {
                pathLength += Math.sqrt(Math.pow(points[i].x - points[i-1].x, 2) + Math.pow(points[i].y - points[i-1].y, 2));
            }

            const error = Math.abs(pathLength - idealPerimeter);
            const normalizedError = error / idealPerimeter;
            return Math.max(0, 100 - (normalizedError * 100));
        };
        
        const calculateClosureScore = () => {
            const startPoint = points[0];
            const endPoint = points[points.length - 1];
            const distance = Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2));
            const maxDistance = Math.min(drawingCanvas.width, drawingCanvas.height) * 0.1;
            
            const normalizedDistance = Math.min(distance, maxDistance) / maxDistance;
            return 100 - (normalizedDistance * 100);
        };

        const updateScores = (roundness, perimeter, closure, overall) => {
            document.getElementById('roundnessScore').textContent = Math.round(roundness);
            document.getElementById('perimeterScore').textContent = Math.round(perimeter);
            document.getElementById('closureScore').textContent = Math.round(closure);
            document.getElementById('overallScore').textContent = Math.round(overall);
        };
        
        const renderHistory = () => {
            const history = JSON.parse(localStorage.getItem(historyKey) || '[]');
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            if (history.length === 0) {
                historyList.innerHTML = '<p style="text-align:center; color:#777;">No game history available.</p>';
            } else {
                history.forEach(item => {
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <div class="history-item-scores">
                            <strong>Overall: ${item.overall}</strong> | Roundness: ${item.roundness}, Perimeter: ${item.perimeter}, Closure: ${item.closure}
                        </div>
                        <div class="history-item-date">${item.date}</div>
                    `;
                    historyList.appendChild(listItem);
                });
            }
        };

        const renderHighScore = () => {
            const highScore = JSON.parse(localStorage.getItem(highScoreKey) || 'null');
            const highScoreDisplay = document.getElementById('highScoreDisplay');
            if (highScore) {
                highScoreDisplay.innerHTML = `
                    <div class="score-value">${highScore.overall}</div>
                    <div class="score-details">
                        Roundness: ${highScore.roundness}, Perimeter: ${highScore.perimeter}, Closure: ${highScore.closure}
                        <br>
                        <small>Achieved on: ${highScore.date}</small>
                    </div>
                `;
                drawPath(highScore.points, highScoreCtx, 'rgba(52, 152, 219, 0.7)');
            } else {
                highScoreDisplay.innerHTML = '<p style="text-align:center; color:#777;">No high score yet. Play a round!</p>';
                highScoreCtx.clearRect(0, 0, highScoreCanvas.width, highScoreCanvas.height);
            }
        };
        
        const showView = (index) => {
            views.forEach((view, i) => {
                view.classList.toggle('active', i === index);
            });
            navigationButton.textContent = buttonTexts[index];
            
            if (views[index] === historyView) {
                renderHistory();
            } else if (views[index] === highScoreView) {
                renderHighScore();
            } else {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                idealCircleCtx.clearRect(0, 0, idealCircleCanvas.width, idealCircleCanvas.height);
                updateScores(0, 0, 0, 0);
            }
            activeViewIndex = index;
        };

        // Event Listeners for drawing, limited to the canvas
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseleave', stopDrawing);
        drawingCanvas.addEventListener('touchstart', startDrawing, {passive: true});
        drawingCanvas.addEventListener('touchmove', draw, {passive: true});
        drawingCanvas.addEventListener('touchend', stopDrawing, {passive: true});
        drawingCanvas.addEventListener('touchcancel', stopDrawing, {passive: true});
        
        // Navigation button listener
        navigationButton.addEventListener('click', () => {
            let nextIndex = (activeViewIndex + 1) % views.length;
            showView(nextIndex);
        });
        
        // Initial view setup
        showView(0);
    </script>
</body>
</html>