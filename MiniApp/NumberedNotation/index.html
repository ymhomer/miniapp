<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Numbered Musical Notation</title>
  <style>
    /* Global style */
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background-color: #f7f7f7;
    }
    /* Toolbar Title */
    #toolbar-title {
      display: none;
      font-size: 1.2em;
      padding: 10px;
      background-color: #3a3a3a;
      color: #fff;
      text-align: center;
      cursor: pointer;
      margin: 0;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      transition: background-color 0.2s;
      z-index: 10;
    }
    #toolbar-title:hover {
      background-color: #4a4a4a;
    }
    /* Top Toolbar */
    #toolbar {
      background-color: #3a3a3a;
      color: #fff;
      padding: 8px 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
    }
    #toolbar button {
      background-color: #555;
      color: #fff;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 6px;
      transition: background-color 0.2s;
    }
    #toolbar button:hover {
      background-color: #777;
    }
    #toolbar label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.9em;
    }
    #toolbar input[type=number],
    #toolbar select {
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #ccc;
      width: 60px;
    }
    /* Reset button */
    #toolbar button.reset-btn {
      background-color: #d9534f;
    }
    #toolbar button.reset-btn:hover {
      background-color: #c9302c;
    }
    /* Library button */
    #toolbar button#library-btn {
      background-color: #007bff;
    }
    #toolbar button#library-btn:hover {
      background-color: #0056b3;
    }
    /* Help button */
    #toolbar button#help-btn {
      background-color: #28a745;
    }
    #toolbar button#help-btn:hover {
      background-color: #218838;
    }
    /* Modals (Help and Library) */
    #helpModal, #libraryModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    #helpModal .modal-content, #libraryModal .modal-content {
      background-color: #fff;
      border-radius: 8px;
      width: 90%;
      max-width: 500px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      position: relative;
    }
    #helpModal .modal-header, #libraryModal .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
      margin-bottom: 10px;
    }
    #helpModal .modal-header h5, #libraryModal .modal-header h5 {
      margin: 0;
      font-size: 1.2em;
      color: #333;
    }
    #helpModal .modal-close, #libraryModal .modal-close {
      background-color: #555;
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #helpModal .modal-close:hover, #libraryModal .modal-close:hover {
      background-color: #777;
    }
    #helpModal .modal-body, #libraryModal .modal-body {
      max-height: 60vh;
      overflow-y: auto;
      color: #333;
      font-size: 0.95em;
    }
    #helpModal .modal-body h6, #libraryModal .modal-body h6 {
      margin-top: 15px;
      font-size: 1em;
      color: #3a3a3a;
    }
    #helpModal .modal-body p, #helpModal .modal-body ul,
    #libraryModal .modal-body p, #libraryModal .modal-body ul {
      margin: 10px 0;
    }
    #helpModal .modal-body ul, #libraryModal .modal-body ul {
      padding-left: 20px;
    }
    #helpModal .modal-body li, #libraryModal .modal-body li {
      margin-bottom: 5px;
    }
    /* Library Modal Specific */
    #libraryModal .modal-body h3 {
      margin: 0 0 6px 0;
      font-size: 1.1em;
    }
    #libraryModal #library-actions {
      margin-bottom: 8px;
    }
    #libraryModal #library-actions button {
      margin-right: 8px;
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.15s;
    }
    #libraryModal #library-actions button#import-btn {
      background-color: #28a745;
      color: #fff;
    }
    #libraryModal #library-actions button#export-btn {
      background-color: #17a2b8;
      color: #fff;
    }
    #libraryModal #library-actions button:hover {
      opacity: 0.9;
    }
    #libraryModal ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #libraryModal li {
      padding: 4px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px dashed #ccc;
    }
    #libraryModal li:last-child {
      border-bottom: none;
    }
    #libraryModal li button {
      font-size: 0.85em;
      padding: 2px 6px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #libraryModal li button.load-btn {
      background-color: #007bff;
      color: #fff;
    }
    #libraryModal li button.delete-btn {
      background-color: #d9534f;
      color: #fff;
    }
    /* Editor Area */
    #editor-area {
      flex-grow: 1;
      overflow-y: auto;
      padding: 12px;
      background-color: #fff;
      border: 1px solid #ddd;
      margin: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      position: relative;
    }
    #score-content {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }
    .measure {
      display: flex;
      flex-direction: column;
      border: 1px solid #aaa;
      padding: 8px;
      min-height: 80px;
      min-width: 150px;
      background-color: #fff;
      box-sizing: border-box;
      border-radius: 6px;
    }
    .measure-header {
      display: flex;
      justify-content: space-between;
      font-size: 0.8em;
      color: #555;
      margin-bottom: 6px;
      align-items: center;
    }
    .time-signature {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }
    .time-signature:hover {
      background-color: #e0e0e0;
    }
    .time-signature.editing {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    .time-signature input[type=number] {
      width: 30px;
      padding: 1px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.8em;
    }
    .time-signature select {
      padding: 1px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.8em;
    }
    .beat-info { color: #888; }
    .beat-info.error { color: #d9534f; font-weight: bold; }
    .notes-container {
      flex-grow: 1;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 4px;
    }
    .note, .rest {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      padding: 4px 6px;
      border: 1px solid transparent;
      border-radius: 4px;
      min-width: 1em;
      text-align: center;
      font-size: 1.2em;
      transition: background-color 0.15s;
      cursor: pointer;
      position: relative;
    }
    .note:hover, .rest:hover { background-color: #f0f0f0; }
    .note.selected, .rest.selected { border: 1px solid #007bff; background-color: #e7f1ff; }
    .note .pitch-container {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .note .pitch { font-weight: bold; }
    .note .octave-dot-above,
    .note .octave-dot-below {
      display: block;
      font-size: 0.8em;
      line-height: 1;
      width: 100%;
      text-align: center;
    }
    .note .octave-dot-above { margin-bottom: 2px; }
    .note .octave-dot-below { margin-top: 2px; }
    .note .accidental { font-size: 0.9em; margin-right: 2px; }
    .note .dot, .note .tie-char { font-weight: bold; margin-left: 2px; }
    .note .duration-char {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 1px;
    }
    .note .duration-char span {
      font-size: 0.6em;
      line-height: 0.7;
      color: #d9534f;
      opacity: 0.9;
      margin: 0;
      padding: 0;
      text-shadow: 0 0 1px rgba(0,0,0,0.1);
    }
    .note .duration-char span:not(:first-child) {
      transform: translateY(-1px);
    }
    .rest { color: #666; font-weight: bold; }
    .rest .pitch-container { display: flex; align-items: center; }
    .rest .dot { font-weight: bold; margin-left: 2px; }
    .rest .duration-char {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 1px;
    }
    .rest .duration-char span {
      font-size: 0.6em;
      line-height: 0.7;
      color: #d9534f;
      opacity: 0.9;
      margin: 0;
      padding: 0;
      text-shadow: 0 0 1px rgba(0,0,0,0.1);
    }
    .rest .duration-char span:not(:first-child) {
      transform: translateY(-1px);
    }
    /* Cursor */
    #cursor {
      display: inline-block;
      width: 2px;
      height: 1.5em;
      background-color: #007bff;
      position: absolute;
      pointer-events: none;
      animation: blink 1s step-end infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }
    /* Bottom Action Bar */
    #action-bar {
      background-color: #f2f2f2;
      padding: 8px 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      flex-shrink: 0;
      border-top: 1px solid #ddd;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
    }
    #action-bar button {
      padding: 6px 10px;
      font-size: 1em;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background-color: #fff;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
      transition: background-color 0.15s;
    }
    #action-bar button:active { background-color: #e6e6e6; }
    #action-bar button sup {
      font-size: 0.6em;
      vertical-align: super;
      background-color: rgba(200, 200, 200, 0.3);
      padding: 1px 2px;
      border-radius: 2px;
      transform: translateY(2px);
      pointer-events: none;
    }
    #action-bar button i {
      margin-right: 2px;
      vertical-align: middle;
    }
    .action-group {
      display: flex;
      gap: 6px;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background-color: #fafafa;
    }
    .action-group span {
      align-self: center;
      font-size: 0.9em;
    }
    /* Responsive: small screens */
    @media (max-width: 600px) {
      #toolbar-title {
        display: block;
        role: button;
      }
      #toolbar {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }
      #toolbar.open {
        max-height: 200px;
        overflow: auto;
      }
      #action-bar { flex-direction: column; }
      #editor-area { margin: 6px; padding: 6px; }
      .measure { min-width: 100px; padding: 4px; }
      .action-group { flex-wrap: wrap; }
      #helpModal .modal-content, #libraryModal .modal-content { width: 95%; }
      .time-signature input[type=number], .time-signature select { width: 25px; font-size: 0.7em; }
    }
    /* Responsive: large screens */
    @media (min-width: 601px) {
      #toolbar-title { display: none; }
      #toolbar { max-height: none; overflow: visible; }
    }
  </style>
</head>
<body>

  <!-- Toolbar Title -->
  <h1 id="toolbar-title" aria-expanded="false" aria-controls="toolbar" role="button">Numbered Musical Notation ‚ñº</h1>

  <!-- Toolbar -->
  <div id="toolbar">
    <button id="play-btn">Play</button>
    <button id="library-btn">Score Library</button>
    <button class="reset-btn" id="reset-btn">Reset</button>
    <button id="help-btn">Help</button>
    <label>
      Base Note:
      <select id="base-note-type">
        <option value="4">Quarter</option>
        <option value="8">Eighth</option>
        <option value="2">Half</option>
      </select>
    </label>
    <label>
      BPM:
      <input type="number" id="bpm-input" value="120" min="30" max="300">
    </label>
  </div>

  <!-- Help Modal -->
  <div id="helpModal">
    <div class="modal-content">
      <div class="modal-header">
        <h5>Jianpu Editor Help</h5>
        <button class="modal-close">Close</button>
      </div>
      <div class="modal-body">
        <h6>Overview</h6>
        <p>This editor allows you to create and edit Jianpu (numbered musical notation) scores. Use the toolbar to play, reset, or manage scores, and the bottom action bar to input notes, rests, and modifications.</p>
        <h6>Key Mappings</h6>
        <ul>
          <li><strong>1‚Äì7</strong>: Insert a note (1=Do, 2=Re, ..., 7=Ti, as shown in the Notes group) at the cursor position.</li>
          <li><strong>0</strong>: Insert a rest (0 with Rest superscript) at the cursor position.</li>
          <li><strong>Backspace/Delete</strong>: Delete the note before the cursor (or use the üóëÔ∏è<sup>Del</sup> button).</li>
          <li><strong>Arrow Left/Right</strong>: Move cursor between notes.</li>
          <li><strong>Home/End</strong>: Move cursor to start/end of measure.</li>
          <li><strong>Arrow Up/Down</strong>: Increase/decrease octave of the note before the cursor or selected note.</li>
          <li><strong>#</strong>: Add sharp to the note before the cursor or selected note.</li>
          <li><strong>b</strong>: Add flat to the note before the cursor or selected note.</li>
          <li><strong>.</strong>: Toggle dotted note (extends duration by 1.5x) for the note before the cursor or selected note.</li>
          <li><strong>-</strong>: Add tie to the note before the cursor or selected note (extends duration).</li>
          <li><strong>_</strong>: Shorten duration (e.g., quarter to eighth, up to 32nd note) for the note before the cursor or selected note.</li>
          <li><strong>Enter</strong>: Add a new measure.</li>
        </ul>
        <h6>Usage Tips</h6>
        <ul>
          <li>Click a note or measure to set the cursor position for inserting, deleting, or modifying.</li>
          <li>Accidental, Octave, and Duration modifications apply to the note before the cursor if no note is selected, or to the selected note if one is clicked.</li>
          <li>Use underscores (_) to shorten note duration, stacked vertically (e.g., three _ for a 32nd note).</li>
          <li>Use dashes (-) for ties, appearing after the note (e.g., 1-).</li>
          <li>Use the Notes group buttons (e.g., 1<sup>Do</sup>, 0<sup>Rest</sup>, üóëÔ∏è<sup>Del</sup>) to add or delete notes/rests.</li>
          <li>Use the Accid group (e.g., #<sup>Sharp</sup>, ‚ô≠<sup>Flat</sup>, ‚Ü∫<sup>Reset</sup>) to modify accidentals.</li>
          <li>Use the Octave group (e.g., ‚Üë<sup>Up</sup>, ‚Üì<sup>Down</sup>, ‚Ü∫<sup>Reset</sup>) to adjust octave.</li>
          <li>Use the Duration group (e.g., .<sup>Dot</sup>, -<sup>Tie</sup>, _<sup>Short</sup>) to modify note duration.</li>
          <li>Click a measure's time signature (e.g., 4/4) to edit beats and beat type.</li>
          <li>Set the Base Note in the toolbar to define duration calculations (e.g., Quarter note as base).</li>
          <li>Monitor the beat info in each measure to ensure correct timing.</li>
          <li>Access the Score Library to import/export scores as JSON files.</li>
          <li>On small screens, tap the "Numbered Musical Notation ‚ñº" title to show/hide the toolbar.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Library Modal -->
  <div id="libraryModal">
    <div class="modal-content">
      <div class="modal-header">
        <h5>Score Library</h5>
        <button class="modal-close">Close</button>
      </div>
      <div class="modal-body">
        <h3>Score Library</h3>
        <div id="library-actions">
          <button id="library-import-btn" title="Import Scores">Import Scores</button>
          <button id="library-export-btn" title="Export Current Score">Export Current Score</button>
        </div>
        <ul id="library-list"></ul>
      </div>
    </div>
  </div>

  <!-- Editor Area -->
  <div id="editor-area">
    <div id="score-content"></div>
    <span id="cursor" style="left: 10px;"></span>
  </div>

  <!-- Bottom Action Bar -->
  <div id="action-bar">
    <div class="action-group">
      <span>Notes:</span>
      <button data-value="1">1<sup>Do</sup></button>
      <button data-value="2">2<sup>Re</sup></button>
      <button data-value="3">3<sup>Mi</sup></button>
      <button data-value="4">4<sup>Fa</sup></button>
      <button data-value="5">5<sup>So</sup></button>
      <button data-value="6">6<sup>La</sup></button>
      <button data-value="7">7<sup>Ti</sup></button>
      <button data-value="0">0<sup>Rest</sup></button>
      <button data-value="delete">üóëÔ∏è<sup>Del</sup></button>
    </div>
    <div class="action-group">
      <span>Accid:</span>
      <button data-value="#">#<sup>Sharp</sup></button>
      <button data-value="b">‚ô≠<sup>Flat</sup></button>
      <button data-value="clear-accid">‚Ü∫<sup>Reset</sup></button>
    </div>
    <div class="action-group">
      <span>Octave:</span>
      <button data-value="octave-up">‚Üë<sup>Up</sup></button>
      <button data-value="octave-down">‚Üì<sup>Down</sup></button>
      <button data-value="octave-clear">‚Ü∫<sup>Reset</sup></button>
    </div>
    <div class="action-group">
      <span>Duration:</span>
      <button data-value="dot">.<sup>Dot</sup></button>
      <button data-value="tie">-<sup>Tie</sup></button>
      <button data-value="shorten">_<sup>Short</sup></button>
    </div>
  </div>

  <!-- Hidden file input -->
  <input type="file" id="import-file" class="hidden" accept=".json, .txt" multiple style="display: none;">

  <script>
    /* Basic Web Audio functions */
    let audioCtx;
    let isPlaying = false;
    let playbackTimeouts = [];
    function initAudio() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error("Web Audio API not supported");
          alert("Web Audio API is not supported, playback disabled.");
        }
      }
    }
    function playTone(pitchVal, octave, durationSeconds, startTime) {
      if (!audioCtx) return;
      const noteFrequencies = { 1: 261.63, 2: 293.66, 3: 329.63, 4: 349.23, 5: 392.00, 6: 440.00, 7: 493.88 };
      let baseFreq = noteFrequencies[pitchVal];
      if (!baseFreq) return;
      let freq = baseFreq * Math.pow(2, octave);
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(freq, startTime);
      gainNode.gain.setValueAtTime(0.5, startTime);
      gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + durationSeconds);
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start(startTime);
      oscillator.stop(startTime + durationSeconds);
    }
    function playFeedback(noteElement) {
      initAudio();
      const pitch = parseInt(noteElement?.dataset.pitch || '1');
      const octave = parseInt(noteElement?.dataset.octave || '0');
      if (pitch > 0) {
        playTone(pitch, octave, 0.3, audioCtx.currentTime);
      }
    }
    function stopPlayback() {
      playbackTimeouts.forEach(clearTimeout);
      playbackTimeouts = [];
      if (audioCtx) {
        audioCtx.close();
        audioCtx = null;
      }
      document.querySelectorAll('.playing').forEach(el => el.classList.remove('playing'));
      isPlaying = false;
      document.getElementById('play-btn').textContent = 'Play';
      console.log("Playback stopped.");
    }
  </script>

  <script>
    // DOM elements
    const editorArea = document.getElementById('editor-area');
    const scoreContent = document.getElementById('score-content');
    const actionBar = document.getElementById('action-bar');
    const cursor = document.getElementById('cursor');
    const baseNoteTypeSelect = document.getElementById('base-note-type');
    const bpmInput = document.getElementById('bpm-input');
    const playBtn = document.getElementById('play-btn');
    const importFileEl = document.getElementById('import-file');
    const libraryBtn = document.getElementById('library-btn');
    const libraryList = document.getElementById('library-list');
    const resetBtn = document.getElementById('reset-btn');
    const libraryImportBtn = document.getElementById('library-import-btn');
    const libraryExportBtn = document.getElementById('library-export-btn');
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('helpModal');
    const helpModalClose = helpModal.querySelector('.modal-close');
    const libraryModal = document.getElementById('libraryModal');
    const libraryModalClose = libraryModal.querySelector('.modal-close');
    const toolbarTitle = document.getElementById('toolbar-title');
    const toolbar = document.getElementById('toolbar');

    // Global state
    let score = {
      baseNoteType: 4,
      bpm: 120,
      measures: []
    };
    let scoreLibrary = [];
    let cursorPosition = { measureIndex: 0, noteIndex: 0 };
    let selectedElement = null;
    let nextId = 0;

    function getNewId() { return `elem-${nextId++}`; }
    function getBeatValue(beatType, baseNoteType) {
      return (4 / beatType) / (4 / baseNoteType);
    }

    function calculateMeasureBeats(measureIndex) {
      if (!score.measures[measureIndex]) return 0;
      let totalBeats = 0;
      const measure = score.measures[measureIndex];
      const beatValue = getBeatValue(measure.timeSignature.beatType, score.baseNoteType);
      measure.notes.forEach(note => {
        let duration = note.durationBase * beatValue;
        if (note.dotted) duration *= 1.5;
        if (note.tieCount > 0) duration += note.durationBase * note.tieCount * beatValue;
        totalBeats += duration;
      });
      return totalBeats;
    }

    // Render note element
    function renderNoteElement(noteData, measureIndex) {
      const noteEl = document.createElement('span');
      noteEl.id = noteData.id;
      noteEl.dataset.measureIndex = measureIndex;
      noteEl.dataset.noteId = noteData.id;
      noteEl.tabIndex = 0;
      Object.keys(noteData).forEach(key => {
        if (typeof noteData[key] !== 'object') noteEl.dataset[key] = noteData[key];
      });
      if (noteData.type === 'note') {
        noteEl.className = 'note';
        let content = '<span class="pitch-container">';
        if (noteData.octave > 0) content += `<span class="octave-dot-above">${'¬∑'.repeat(noteData.octave)}</span>`;
        if (noteData.accidental) content += `<span class="accidental">${noteData.accidental}</span>`;
        content += `<span class="pitch">${noteData.pitch}</span>`;
        if (noteData.dotted) content += `<span class="dot">.</span>`;
        if (noteData.tieCount > 0) content += `<span class="tie-char">${'-'.repeat(noteData.tieCount)}</span>`;
        if (noteData.octave < 0) content += `<span class="octave-dot-below">${'¬∑'.repeat(Math.abs(noteData.octave))}</span>`;
        content += '</span>';
        if (noteData.durationBase < 1) {
          const underscoreCount = Math.log2(1 / noteData.durationBase);
          content += '<span class="duration-char">';
          for (let i = 0; i < underscoreCount; i++) content += '<span>_</span>';
          content += '</span>';
        }
        noteEl.innerHTML = content;
      } else if (noteData.type === 'rest') {
        noteEl.className = 'rest';
        let content = '<span class="pitch-container">0';
        if (noteData.dotted) content += `<span class="dot">.</span>`;
        content += '</span>';
        if (noteData.durationBase < 1) {
          const underscoreCount = Math.log2(1 / noteData.durationBase);
          content += '<span class="duration-char">';
          for (let i = 0; i < underscoreCount; i++) content += '<span>_</span>';
          content += '</span>';
        }
        noteEl.innerHTML = content;
      }
      noteEl.addEventListener('click', (event) => {
        event.stopPropagation();
        selectElement(noteEl);
        const noteIndex = score.measures[measureIndex].notes.findIndex(n => n.id === noteData.id);
        moveCursorTo(measureIndex, noteIndex);
        playFeedback(noteEl);
      });
      let pressTimer;
      noteEl.addEventListener('touchstart', (e) => {
        pressTimer = setTimeout(() => selectElement(noteEl), 800);
      });
      noteEl.addEventListener('touchend', () => clearTimeout(pressTimer));
      noteEl.addEventListener('touchmove', () => clearTimeout(pressTimer));
      noteEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        selectElement(noteEl);
      });
      return noteEl;
    }

    function renderMeasure(measureData, measureIndex) {
      const measureEl = document.createElement('div');
      measureEl.className = 'measure';
      measureEl.id = measureData.id;
      measureEl.dataset.measureIndex = measureIndex;
      const headerEl = document.createElement('div');
      headerEl.className = 'measure-header';
      const timeSigEl = document.createElement('span');
      timeSigEl.className = 'time-signature';
      timeSigEl.textContent = `${measureData.timeSignature.beats}/${measureData.timeSignature.beatType}`;
      timeSigEl.dataset.beats = measureData.timeSignature.beats;
      timeSigEl.dataset.beatType = measureData.timeSignature.beatType;
      timeSigEl.addEventListener('click', () => {
        if (timeSigEl.classList.contains('editing')) return;
        timeSigEl.classList.add('editing');
        timeSigEl.innerHTML = `
          <input type="number" class="beats" value="${measureData.timeSignature.beats}" min="1" step="1">
          /
          <select class="beat-type">
            <option value="4" ${measureData.timeSignature.beatType === 4 ? 'selected' : ''}>4</option>
            <option value="8" ${measureData.timeSignature.beatType === 8 ? 'selected' : ''}>8</option>
            <option value="2" ${measureData.timeSignature.beatType === 2 ? 'selected' : ''}>2</option>
          </select>
        `;
        const beatsInput = timeSigEl.querySelector('.beats');
        const beatTypeSelect = timeSigEl.querySelector('.beat-type');
        const saveTimeSig = () => {
          const newBeats = parseInt(beatsInput.value) || 1;
          const newBeatType = parseInt(beatTypeSelect.value);
          score.measures[measureIndex].timeSignature = { beats: Math.max(1, newBeats), beatType: newBeatType };
          timeSigEl.classList.remove('editing');
          timeSigEl.textContent = `${newBeats}/${newBeatType}`;
          timeSigEl.dataset.beats = newBeats;
          timeSigEl.dataset.beatType = newBeatType;
          updateMeasureBeatInfo(measureEl, measureIndex);
        };
        beatsInput.addEventListener('blur', saveTimeSig);
        beatTypeSelect.addEventListener('blur', saveTimeSig);
        beatsInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') saveTimeSig(); });
        beatsInput.focus();
      });
      const beatInfoEl = document.createElement('span');
      beatInfoEl.className = 'beat-info';
      headerEl.appendChild(timeSigEl);
      headerEl.appendChild(beatInfoEl);
      measureEl.appendChild(headerEl);
      const notesContainer = document.createElement('div');
      notesContainer.className = 'notes-container';
      measureData.notes.forEach(noteData => {
        notesContainer.appendChild(renderNoteElement(noteData, measureIndex));
      });
      measureEl.appendChild(notesContainer);
      measureEl.addEventListener('click', (event) => {
        if (event.target === measureEl || event.target === notesContainer) {
          const mIndex = parseInt(measureEl.dataset.measureIndex);
          const noteCount = score.measures[mIndex].notes.length;
          moveCursorTo(mIndex, noteCount);
          deselectElement();
        }
      });
      updateMeasureBeatInfo(measureEl, measureIndex);
      return measureEl;
    }

    function updateMeasureBeatInfo(measureElement, measureIndex) {
      const beatInfoEl = measureElement.querySelector('.beat-info');
      if (!beatInfoEl) return;
      const currentBeats = calculateMeasureBeats(measureIndex);
      const targetBeats = score.measures[measureIndex].timeSignature.beats;
      beatInfoEl.textContent = `${currentBeats.toFixed(2)} / ${targetBeats}`;
      if (Math.abs(currentBeats - targetBeats) > 0.01) beatInfoEl.classList.add('error');
      else beatInfoEl.classList.remove('error');
    }

    function renderScore() {
      scoreContent.innerHTML = '';
      score.measures.forEach((measureData, index) => {
        scoreContent.appendChild(renderMeasure(measureData, index));
      });
      updateCursorPosition();
    }

    // Cursor management
    function moveCursorTo(measureIndex, noteIndex) {
      measureIndex = Math.max(0, Math.min(measureIndex, score.measures.length - 1));
      if (score.measures.length === 0) {
        measureIndex = -1;
        noteIndex = 0;
      } else if (measureIndex >= 0) {
        noteIndex = Math.max(0, Math.min(noteIndex, score.measures[measureIndex].notes.length));
      }
      cursorPosition.measureIndex = measureIndex;
      cursorPosition.noteIndex = noteIndex;
      updateCursorPosition();
      deselectElement();
    }

    function updateCursorPosition() {
      if (cursorPosition.measureIndex < 0 || score.measures.length === 0) {
        cursor.style.left = `10px`;
        cursor.style.top = `25px`;
        cursor.style.display = 'inline-block';
        return;
      }
      const measureElement = scoreContent.children[cursorPosition.measureIndex];
      if (!measureElement) {
        cursor.style.display = 'none';
        return;
      }
      const notesContainer = measureElement.querySelector('.notes-container');
      if (!notesContainer) {
        cursor.style.display = 'none';
        return;
      }
      let targetElement;
      let isEndOfMeasure = cursorPosition.noteIndex >= notesContainer.children.length;
      if (!isEndOfMeasure) {
        targetElement = notesContainer.children[cursorPosition.noteIndex];
      } else {
        targetElement = notesContainer.children[notesContainer.children.length - 1] || notesContainer;
      }
      if (targetElement) {
        const rect = targetElement.getBoundingClientRect();
        const containerRect = scoreContent.getBoundingClientRect();
        let left = rect.left - containerRect.left + editorArea.scrollLeft;
        if (isEndOfMeasure) {
          left += rect.width;
        }
        let top = rect.top - containerRect.top + (rect.height / 2) - (cursor.offsetHeight / 2) + 5;
        cursor.style.left = `${left}px`;
        cursor.style.top = `${top}px`;
        cursor.style.display = 'inline-block';
        editorArea.scrollTo({ top: editorArea.scrollTop + rect.top - containerRect.top - 50, behavior: 'smooth' });
      } else {
        cursor.style.display = 'none';
      }
    }

    // Selection management
    function selectElement(element) {
      deselectElement();
      if (element) {
        selectedElement = element;
        selectedElement.classList.add('selected');
        selectedElement.focus();
      }
    }

    function deselectElement() {
      if (selectedElement) {
        selectedElement.classList.remove('selected');
        selectedElement.blur();
      }
      selectedElement = null;
    }

    function getNoteDataFromElement(element) {
      if (!element || !element.dataset || !element.dataset.noteId) return null;
      const measureIndex = parseInt(element.dataset.measureIndex);
      const noteId = element.dataset.noteId;
      if (isNaN(measureIndex) || !noteId || !score.measures[measureIndex]) return null;
      return score.measures[measureIndex].notes.find(n => n.id === noteId);
    }

    // Get note at cursor position
    function getNoteDataAtCursor() {
      if (cursorPosition.measureIndex < 0 || score.measures.length === 0) return null;
      const measure = score.measures[cursorPosition.measureIndex];
      if (!measure || cursorPosition.noteIndex <= 0) return null;
      return measure.notes[cursorPosition.noteIndex - 1];
    }

    // Insert note
    function insertNote(noteData) {
      if (calculateMeasureBeats(cursorPosition.measureIndex) >= score.measures[cursorPosition.measureIndex].timeSignature.beats - 0.001) {
        addMeasure();
      }
      const measure = score.measures[cursorPosition.measureIndex];
      if (!measure) return;
      const fullNoteData = {
        id: getNewId(),
        type: 'note',
        pitch: 1,
        octave: 0,
        durationBase: 1,
        tieCount: 0,
        accidental: null,
        dotted: false,
        ...noteData
      };
      measure.notes.splice(cursorPosition.noteIndex, 0, fullNoteData);
      cursorPosition.noteIndex++;
      renderScore();
      const newElement = document.getElementById(fullNoteData.id);
      if (newElement) {
        selectElement(newElement);
        playFeedback(newElement);
      }
    }

    // Delete
    function deleteNoteAtCursor() {
      if (cursorPosition.measureIndex < 0 || score.measures.length === 0) return;
      const measure = score.measures[cursorPosition.measureIndex];
      if (!measure) return;
      if (measure.notes.length === 0) {
        if (score.measures.length > 1) {
          score.measures.splice(cursorPosition.measureIndex, 1);
          cursorPosition.measureIndex = Math.max(0, cursorPosition.measureIndex - 1);
          cursorPosition.noteIndex = score.measures[cursorPosition.measureIndex].notes.length;
          renderScore();
          return;
        }
        return;
      }
      let deleteIndex = cursorPosition.noteIndex - 1;
      if (deleteIndex >= 0) {
        measure.notes.splice(deleteIndex, 1);
        cursorPosition.noteIndex = deleteIndex;
        renderScore();
      }
      deselectElement();
    }

    function deleteNoteAtElement(element) {
      const data = getNoteDataFromElement(element);
      if (!data) return;
      const measureIndex = parseInt(element.dataset.measureIndex);
      const measure = score.measures[measureIndex];
      const noteIndex = measure.notes.findIndex(n => n.id === data.id);
      if (noteIndex !== -1) {
        measure.notes.splice(noteIndex, 1);
        if (cursorPosition.measureIndex === measureIndex && cursorPosition.noteIndex > noteIndex) {
          cursorPosition.noteIndex--;
        }
        renderScore();
        deselectElement();
      }
    }

    // Modify note at cursor or selected note
    function modifyNoteAtCursor(property, value) {
      let targetNote = null;
      let targetElement = selectedElement;
      let measureIndex = cursorPosition.measureIndex;
      let noteIndex = cursorPosition.noteIndex - 1;

      // Prefer selected note if available
      if (selectedElement) {
        targetNote = getNoteDataFromElement(selectedElement);
        measureIndex = parseInt(selectedElement.dataset.measureIndex);
        noteIndex = score.measures[measureIndex].notes.findIndex(n => n.id === targetNote.id);
      } else {
        // Otherwise, use note before cursor
        targetNote = getNoteDataAtCursor();
        targetElement = targetNote ? document.getElementById(targetNote.id) : null;
      }

      if (!targetNote) {
        console.log("No note to modify at cursor or selected.");
        return;
      }

      const measure = score.measures[measureIndex];
      let needsRender = true;
      switch (property) {
        case 'pitch':
          if (targetNote.type === 'note') targetNote.pitch = parseInt(value);
          break;
        case 'type':
          targetNote.type = value;
          if (value === 'rest') {
            targetNote.pitch = 0;
            targetNote.octave = 0;
            targetNote.accidental = null;
            targetNote.tieCount = 0;
          } else {
            targetNote.pitch = targetNote.pitch || 1;
          }
          break;
        case 'accidental':
          if (targetNote.type === 'note') {
            if (value === '#' && (targetNote.pitch === 3 || targetNote.pitch === 7)) {
              console.warn("Cannot raise E(3) or B(7)");
              return;
            }
            targetNote.accidental = (targetNote.accidental === value) ? null : value;
          }
          break;
        case 'octave':
          if (targetNote.type === 'note') {
            if (value === '+1') targetNote.octave++;
            else if (value === '-1') targetNote.octave--;
            else if (value === 'clear') targetNote.octave = 0;
            targetNote.octave = Math.max(-2, Math.min(2, targetNote.octave));
          }
          break;
        case 'shorten':
          if (targetNote.type === 'rest' || targetNote.type === 'note') {
            targetNote.durationBase = Math.max(0.125, targetNote.durationBase / 2);
            if (targetNote.type === 'rest') targetNote.tieCount = 0;
          }
          break;
        case 'tie':
          if (targetNote.type === 'note') targetNote.tieCount++;
          else {
            console.warn("Cannot apply tie '-' to rests");
            return;
          }
          break;
        case 'dotted':
          if (targetNote.type === 'rest' || targetNote.type === 'note') targetNote.dotted = !targetNote.dotted;
          else {
            console.warn("Cannot dot this element type");
            return;
          }
          break;
        default:
          needsRender = false;
      }
      if (needsRender) {
        // Check if measure is overfilled
        if (calculateMeasureBeats(measureIndex) > measure.timeSignature.beats + 0.001) {
          addMeasure();
          // Move cursor to new measure
          cursorPosition.measureIndex++;
          cursorPosition.noteIndex = 0;
        }
        renderScore();
        // Re-select the modified note
        const reselected = document.getElementById(targetNote.id);
        if (reselected) selectElement(reselected);
        playFeedback(reselected);
      }
    }

    // Add a new measure
    function addMeasure() {
      const newMeasure = {
        id: getNewId(),
        timeSignature: { beats: 4, beatType: 4 },
        notes: []
      };
      score.measures.splice(cursorPosition.measureIndex + 1, 0, newMeasure);
      cursorPosition.measureIndex++;
      cursorPosition.noteIndex = 0;
      renderScore();
    }

    // Reset the editor
    function resetEditor() {
      if (confirm("Are you sure you want to reset the editor? All content will be lost.")) {
        score = { baseNoteType: 4, bpm: 120, measures: [] };
        nextId = 0;
        addMeasure();
        moveCursorTo(0, 0);
        baseNoteTypeSelect.value = '4';
      }
    }

    // Event listeners for bottom action bar and keyboard
    actionBar.addEventListener('click', (event) => {
      const button = event.target.closest('button');
      if (!button) return;
      const action = button.dataset.value;
      if (!action) return;
      initAudio();
      if (['1','2','3','4','5','6','7'].includes(action)) {
        insertNote({ type: 'note', pitch: parseInt(action) });
      } else if (action === '0') {
        insertNote({ type: 'rest', pitch: 0 });
      } else if (action === 'delete') {
        deleteNoteAtCursor();
      } else {
        if (action === '#') modifyNoteAtCursor('accidental', '#');
        else if (action === 'b') modifyNoteAtCursor('accidental', 'b');
        else if (action === 'clear-accid') modifyNoteAtCursor('accidental', null);
        else if (action === 'octave-up') modifyNoteAtCursor('octave', '+1');
        else if (action === 'octave-down') modifyNoteAtCursor('octave', '-1');
        else if (action === 'octave-clear') modifyNoteAtCursor('octave', 'clear');
        else if (action === 'dot') modifyNoteAtCursor('dotted', true);
        else if (action === 'tie') modifyNoteAtCursor('tie', true);
        else if (action === 'shorten') modifyNoteAtCursor('shorten', true);
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.target.tagName === 'INPUT' || event.target.tagName === 'SELECT' || event.target.tagName === 'TEXTAREA') return;
      initAudio();
      const key = event.key;
      let handled = true;
      if (key >= '1' && key <= '7') {
        insertNote({ type: 'note', pitch: parseInt(key) });
      } else if (key === '0') {
        insertNote({ type: 'rest', pitch: 0 });
      } else if (key === 'Backspace' || key === 'Delete') {
        deleteNoteAtCursor();
      } else if (key === 'ArrowLeft') {
        if (cursorPosition.noteIndex > 0) {
          moveCursorTo(cursorPosition.measureIndex, cursorPosition.noteIndex - 1);
        } else if (cursorPosition.measureIndex > 0) {
          const prevMeasureIndex = cursorPosition.measureIndex - 1;
          moveCursorTo(prevMeasureIndex, score.measures[prevMeasureIndex].notes.length);
        }
      } else if (key === 'ArrowRight') {
        const currentMeasure = score.measures[cursorPosition.measureIndex];
        if (!currentMeasure) return;
        if (cursorPosition.noteIndex < currentMeasure.notes.length) {
          moveCursorTo(cursorPosition.measureIndex, cursorPosition.noteIndex + 1);
        } else if (cursorPosition.measureIndex < score.measures.length - 1) {
          moveCursorTo(cursorPosition.measureIndex + 1, 0);
        }
      } else if (key === 'Home') {
        moveCursorTo(cursorPosition.measureIndex, 0);
      } else if (key === 'End') {
        const currentMeasure = score.measures[cursorPosition.measureIndex];
        moveCursorTo(cursorPosition.measureIndex, currentMeasure.notes.length);
      } else if (key === 'ArrowUp') {
        modifyNoteAtCursor('octave', '+1');
      } else if (key === 'ArrowDown') {
        modifyNoteAtCursor('octave', '-1');
      } else if (key === '#') {
        modifyNoteAtCursor('accidental', '#');
      } else if (key === 'b') {
        modifyNoteAtCursor('accidental', 'b');
      } else if (key === '.') {
        modifyNoteAtCursor('dotted', true);
      } else if (key === '-') {
        modifyNoteAtCursor('tie', true);
      } else if (key === '_') {
        modifyNoteAtCursor('shorten', true);
      } else if (key === 'Enter') {
        addMeasure();
      } else {
        handled = false;
      }
      if (handled) event.preventDefault();
    });

    // Base note type change
    baseNoteTypeSelect.addEventListener('change', () => {
      score.baseNoteType = parseInt(baseNoteTypeSelect.value);
      renderScore();
    });

    // Reset button
    resetBtn.addEventListener('click', resetEditor);

    // Help modal
    helpBtn.addEventListener('click', () => {
      helpModal.style.display = 'flex';
    });
    helpModalClose.addEventListener('click', () => {
      helpModal.style.display = 'none';
    });
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) helpModal.style.display = 'none';
    });

    // Library modal
    libraryBtn.addEventListener('click', () => {
      libraryModal.style.display = 'flex';
      updateLibraryList();
    });
    libraryModalClose.addEventListener('click', () => {
      libraryModal.style.display = 'none';
    });
    libraryModal.addEventListener('click', (e) => {
      if (e.target === libraryModal) libraryModal.style.display = 'none';
    });

    // Score Library Functions
    function generateScoreDataForExport() {
      return JSON.parse(JSON.stringify(score));
    }

    // Export the current score as JSON
    libraryExportBtn.addEventListener('click', () => {
      const scoreData = generateScoreDataForExport();
      const jsonString = JSON.stringify(scoreData, null, 2);
      let fileName = prompt("Please enter file name for export (without extension):", "jianpu_score");
      if (!fileName) fileName = "jianpu_score";
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName + '.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Import Scores
    libraryImportBtn.addEventListener('click', () => {
      importFileEl.click();
    });

    // Handle file input change for importing multiple files
    importFileEl.addEventListener('change', (event) => {
      const files = event.target.files;
      if (!files || files.length === 0) return;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            if (importedData && importedData.baseNoteType && importedData.measures && importedData.measures.every(m => m.timeSignature)) {
              scoreLibrary.push({ name: file.name, data: importedData });
              updateLibraryList();
            } else {
              alert(`File "${file.name}" is not a valid score format.`);
            }
          } catch (err) {
            console.error("Error parsing JSON file:", err);
            alert(`Error loading file "${file.name}": ${err.message}`);
          }
        };
        reader.onerror = (err) => {
          console.error("File reading error:", err);
          alert(`Error reading file "${file.name}".`);
        };
        reader.readAsText(file);
      }
      event.target.value = "";
    });

    // Update the library list UI
    function updateLibraryList() {
      libraryList.innerHTML = "";
      scoreLibrary.forEach((item, index) => {
        const li = document.createElement('li');
        li.textContent = item.name;
        const loadBtn = document.createElement('button');
        loadBtn.textContent = "Load Score";
        loadBtn.className = "load-btn";
        loadBtn.addEventListener('click', () => {
          nextId = 0;
          item.data.measures.forEach(measure => {
            measure.id = getNewId();
            measure.notes.forEach(note => note.id = getNewId());
          });
          score = JSON.parse(JSON.stringify(item.data));
          baseNoteTypeSelect.value = score.baseNoteType;
          bpmInput.value = score.bpm;
          renderScore();
          moveCursorTo(0, 0);
          alert(`Score "${item.name}" loaded into editor.`);
          libraryModal.style.display = 'none';
        });
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = "Delete";
        deleteBtn.className = "delete-btn";
        deleteBtn.addEventListener('click', () => {
          if (confirm(`Delete score "${item.name}" from library?`)) {
            scoreLibrary.splice(index, 1);
            updateLibraryList();
          }
        });
        li.appendChild(loadBtn);
        li.appendChild(deleteBtn);
        libraryList.appendChild(li);
      });
    }

    // Playback
    playBtn.addEventListener('click', () => {
      if (isPlaying) {
        stopPlayback();
      } else {
        playbackTimeouts.forEach(clearTimeout);
        playbackTimeouts = [];
        initAudio();
        if (!audioCtx) return;
        console.log("Starting playback...");
        isPlaying = true;
        playBtn.textContent = 'Stop';
        let currentTime = audioCtx.currentTime + 0.1;
        const secondsPerBeat = 60.0 / score.bpm;
        document.querySelectorAll('.playing').forEach(el => el.classList.remove('playing'));
        score.measures.forEach((measure) => {
          const beatValue = getBeatValue(measure.timeSignature.beatType, score.baseNoteType);
          measure.notes.forEach((note) => {
            const noteElement = document.getElementById(note.id);
            const noteStartTime = currentTime;
            let durationInBeats = note.durationBase * beatValue;
            if (note.dotted) durationInBeats *= 1.5;
            if (note.tieCount > 0) durationInBeats += note.durationBase * note.tieCount * beatValue;
            const durationSeconds = durationInBeats * secondsPerBeat;
            if (note.type === 'note') playTone(note.pitch, note.octave, durationSeconds, noteStartTime);
            if (noteElement) {
              const delay = Math.max(0, (noteStartTime - audioCtx.currentTime) * 1000);
              playbackTimeouts.push(setTimeout(() => {
                if (!isPlaying) return;
                document.querySelectorAll('.playing').forEach(el => el.classList.remove('playing'));
                noteElement.classList.add('playing');
                noteElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
              }, delay));
            }
            currentTime += durationSeconds;
          });
        });
        playbackTimeouts.push(setTimeout(() => {
          if (!isPlaying) return;
          stopPlayback();
        }, Math.max(0, (currentTime - audioCtx.currentTime) * 1000)));
      }
    });

    const additionalStyle = document.createElement('style');
    additionalStyle.innerHTML = `.note.playing, .rest.playing { background-color: yellow !important; }`;
    document.head.appendChild(additionalStyle);

    // Initialize score
    function initializeEmptyScore() {
      console.log("Initializing new empty score.");
      score = { baseNoteType: 4, bpm: 120, measures: [] };
      addMeasure();
      moveCursorTo(0, 0);
    }

    document.addEventListener('DOMContentLoaded', () => {
      initializeEmptyScore();
      renderScore();
      if (toolbarTitle && toolbar) {
        const toggleToolbar = () => {
          console.log("Toolbar title toggled");
          toolbar.classList.toggle('open');
          toolbarTitle.setAttribute('aria-expanded', toolbar.classList.contains('open'));
        };
        toolbarTitle.addEventListener('click', toggleToolbar);
        toolbarTitle.addEventListener('touchstart', (e) => {
          e.preventDefault();
          toggleToolbar();
        });
      }
    });

    editorArea.addEventListener('touchstart', (e) => {
      if (e.touches.length > 1) {}
    }, { passive: false });

    editorArea.addEventListener('scroll', () => {});
  </script>
</body>
</html>
